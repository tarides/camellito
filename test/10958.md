mimoo | 2022-12-14 02:12:51 UTC | #1

That's probably not a good question to ask here, as most people here are surely people who persisted and made it (or are on the way there). But I'm still wondering what prevents OCaml from being more widely adopted as a language, and more, what made people who could have benefited from (and contributed to) OCaml give up.

My guess would be these three, in order of importance:

1. The compiler errors. Personally I think this is the biggest hurdle to get over with when learning OCaml. I wanted to give up many times due to this and had to spend way too much time understanding how to parse them. Even today, I tend to copy/paste and add spacing here and there so that my eyes can go through them, and I still find them unhelpful to deal with a number of errors.
2. The number of resources in haskell, and the lack of good documentation. Most time when I google about concepts or libraries that I run into in OCaml, I don't find much. And if I find something, it'll probably be something about Haskell. There gotta be a number of people who take this as an opportunity to switch language and learn Haskell instead.
3. The tooling. Compared to cargo/go, the combination of opam and dune is extremely hard to use, doesn't have good documentation, and feels cumbersome (probably because their responsibilities overlap). It very much feels like I'm dealing with Makefiles most of the time. I think the lack of convention in OCaml land probably stops a number of beginners.

What do you think are the top reasons?

-------------------------

jfeser | 2022-12-14 15:23:42 UTC | #2

I remember debugging being a serious pain when I first started. Specifically, the lack of a polymorphic print function is a big issue. Many (most?) new ocaml users come from languages where adding print statements is the easiest way to debug a program. If I could have one new language feature to make life easier for beginners, that would be it.

Otherwise, I think the tooling has made huge strides since I started with the language (~2013). Dune is generally very good. I love being able to just clone dependencies into my repo and start hacking on them. Opam is just fine for new users. We have a great lsp server and really polished vscode support. Debugger support is still a pain point, but we have a real wealth of tracing tools.

-------------------------

Chet_Murthy | 2022-12-14 16:13:37 UTC | #3

[quote="jfeser, post:2, topic:10958"]
the lack of a polymorphic print function is a big issue.
[/quote]

Two thoughts:
1. Rust doesn't have one either
2. BUT Rust has traits/modular-implicits, which make ... "composing" such a print-function pretty easy.

-------------------------

pat | 2022-12-14 17:14:13 UTC | #4

I think it depends on the type of "newcomer".

If you mean new to programming in general, probably a ML is not the easiest to pick up, compared to something like python. Theres many concepts that are harder to grasp than it is in python. Also terminology can be off-putting (applicatives, monads, functors etc).

Another "newcomer" might be someone who has done lots of web programming, as its an easy start for many developers. Here, almost every app is built on the fact that http is involved, meaning you want to have a server, and most likely a database. Here i see ocaml lacking a bit. There is not a "goto" http server library, and documentation is not as good as any other popular web language might have. Also the database side is tricky. Theres not a goto library for this.

On the ocaml-on-the-web i sometimes wonder if you could build a new library on-top of 5.0 effects, and completely remove the need for monads. Time will tell. The bottom line is both the server and the database library needs to be async, and ocaml having two competing libraries for this does not help the newcomer.

-------------------------

jfeser | 2022-12-14 21:24:32 UTC | #5

That‚Äôs true, but rust has the print! macro. I don‚Äôt think print is passed as an argument often, so a macro is just fine. 

You can sort of get this in ocaml with ppx, but it requires type annotations, and you have to install and set up the ppx. That isn‚Äôt terrible, and using ppxes has gotten much easier over time, but it‚Äôs a UX hurdle that I wish we didn‚Äôt have.

Particularly when working in a classroom setting, it lowers friction a lot if you only have to install the compiler.

-------------------------

lepoetemaudit | 2022-12-15 10:27:19 UTC | #6

[quote="pat, post:4, topic:10958"]
On the ocaml-on-the-web i sometimes wonder if you could build a new library on-top of 5.0 effects, and completely remove the need for monads. Time will tell. The bottom line is both the server and the database library needs to be async, and ocaml having two competing libraries for this does not help the newcomer.
[/quote]

Yes! I've been playing with eio-cohttp and it's quite wonderful. So much so I started making an experimental ground-up library for Postgres using [eio](https://github.com/ocaml-multicore/eio) and it's been a very pleasant experience so far. I would love the community to rally around such efforts and bless effects-based libraries when the time comes.

Eio even gives proper stack traces from exceptions, something that seems to be swallowed up all the time by Lwt despite trying to be disciplined in how I use it, which is a major help in debugging async code.

-------------------------

Khady | 2022-12-15 10:34:43 UTC | #7

[quote="mimoo, post:1, topic:10958"]
probably because their responsibilities overlap
[/quote]

It's actually the opposite. cargo/go are doing multiple things at the same time. While opam and dune cover different things
- opam does package management (similar to apt/yum/npm/pip)
- dune is a build system (like CMake or meson in C/C++ and webpack in the js world)

So the integration between the two is not really tight and not as smooth as what cargo can do

-------------------------

mimoo | 2022-12-15 10:50:43 UTC | #8

By that I meant I need to declare dependencies in both opam and dune file, I think it gets complicated if its transitive dependencies or dev deps, and the naming is different (dune has mod.submod, opam will use the public name, and ocaml will use Mod_submod)

-------------------------

dbuenzli | 2022-12-15 20:53:12 UTC | #9

[quote="mimoo, post:8, topic:10958"]
and the naming is different (dune has mod.submod, opam will use the public name, and ocaml will use Mod_submod)
[/quote]

Indeed, what you need to understand is that there are four kind of names: 

* `opam` package names (e.g. `ocaml`)
* `ocamlfind` packages names (what dune calls library names, e.g. `compiler-libs.common`)
* OCaml library archive names (e.g. `ocamlcommon.cm[x]a`)
* OCaml module names (more precisely compilation unit names, derived from source files)

None of these names need to coincide or be included in each other and there is no one-to-one mapping. An `opam` package name represents a set of ocamlfind packages. An ocamlfind package represent library archives to link (but nowadays are mostly one-to-one with library archives) and an archive name represents a set of modules: those that are contained therein.

Yes, it's an embarrassing mess. 

I once spent a significant amount of energy to try to clear it with a complete compability story [here](https://github.com/ocaml/RFCs/blob/master/rfcs/ocamlib.md).  But there is no interest. Upstream doesn't seem to care[^1], and `dune` people seem happy to live in their own bubble.

[^1]: Which is rather unfortunate. Leaving the dependency and linking model up for interpretation is not such a good idea. Equipped with these in the compiler there are quite a few places where the user experience can be improved.

-------------------------

BikalGurung | 2022-12-16 09:39:16 UTC | #10

[quote="dbuenzli, post:9, topic:10958"]
I once spent a significant amount of energy to try to clear it with a complete compability story [here ](https://github.com/ocaml/RFCs/blob/master/rfcs/ocamlib.md). But there is no interest. Upstream doesn‚Äôt seem to care[[1]](#footnote-47139-1), and `dune` people seem happy to live in their own bubble.
[/quote]

Indeed, I was closely following the development and was looking forward to it being landed in the upstream. But alas not to be. This would have greatly simplified the OCaml artifact names I think. Additionally, I think it would have opened the possibility of the `ocamlc /ocamlc.opt` binary being as good as `dune` to build OCaml artefacts. 

Are there any counter proposals in public with regards to that rfc?

-------------------------

dbuenzli | 2022-12-16 13:03:53 UTC | #11

[quote="BikalGurung, post:10, topic:10958"]
Are there any counter proposals in public with regards to that rfc?
[/quote]

Not that I'm aware of, the status quo is likely to be political as well. There is [the namespace proposal](https://github.com/lpw25/namespaces) but when we were discussing the RFC the library linking proposal was rather seen as a first step towards it. Other than that [this RFC](https://github.com/ocaml/RFCs/pull/31) brings a few clarifications on the underspecified compilation and dependency model but it doesn't solve any problems on the current conceptual mess.

-------------------------

Leonidas | 2022-12-16 13:29:38 UTC | #12

It's even better, it has `deriving` built-in (something I've been wanting in OCaml since‚Ä¶ years), thus allowing the compiler to just derive the `Debug` trait, which includes printers (while not doing anything in release builds I assume, so without sacrificing the generated code size). So while the initial experience of not being able to print a random value with `{}` is reminiscent of OCaml, using `{:?}` and deriving `Debug` was pretty straightforward. Contrast this to `%a` and either having to depend on `ppx_deriving_show` or composing a debug printer using `Fmt.Dump.*`, in practice this is much more ergonomic on the Rust side because it *just works* (also due to the compiler telling you to derive `Debug` in the error message).

I'm not likely to switch to Rust soon but revisiting Rust 1.65 after my last foray into it at version 0.9 it was full of genuinely nice ideas that made onboarding on a rather complex language quite pleasant.

-------------------------

jbeckford | 2022-12-16 15:58:24 UTC | #13

I'm teaching OCaml to a few high school students who only have a senior ("AP") Java background. I'm not re-inventing the wheel; much of the teaching material comes from the Cornell CS3110 course. And a couple students are interning with me, so I'm highly motivated to track down the newcomer problem spots. So far the problems have been:

1. Explaining the need for `eval $(opam env)` or the equivalent on Windows.
2. How to fix `Unbound module XXX`. *Which is related to ...*
3. What `(libraries xxx)` corresponds to what Opam package.
4. Almost every time they wrote a `dune` file something went wrong. This has been "fixed" so far by writing [a tiny, task-oriented intro to Dune](https://jonbec11.dreamhosters.com/ocaml-training/2022/12/06/basics-of-ocaml-testing/). *Which is related to ...*
5. Almost all of the documentation for OCaml libraries is API-level documentation. For example, the regular expression [re](https://v3.ocaml.org/p/re/1.10.4/doc/Re/index.html) library has very good API-level documentation, and it has *some* examples. But the quantity and comprehensiveness of the examples aren't sufficient to help a newcomer. So I'll be teaching a tribal-knowledge trick: looking at a library's unit tests in its source code. *If only test code was automatically included in the documentation!*

I'm sure at some point we'll run into some Windows OCaml problems as well (every high school student in my Seattle metropolitan area uses Windows for their home PC).

In contrast to all the above environmental problems, the OCaml language itself has been relatively easy to understand (so far!). I think that is because we can write substantial programs in OCaml without having to know much advanced OCaml (honestly, how often do we need first-class modules and GADTs?). That is in contrast to other languages like Rust where advanced understanding is needed for even trivial programs.

-------------------------

Ulugbek | 2022-12-16 16:29:47 UTC | #14

*Absolutely* agree on all five points, looking back at when I was starting out with ocaml. I still can‚Äôt solve point 3 without opening the lib‚Äôs repo and looking into dune files.

upd: I was suggested on discord that running `dune installed-libraries` (or `ocamlfind list`) and grepping can help with that :-)

-------------------------

gasche | 2022-12-16 16:56:41 UTC | #15

Replying to the original list.

1. Error messages: my guess would be that this depends a lot on the background of the student. My experience with students without any programming background is that they don't real error messages at all -- in any language -- they are just interested in the source location. For people that already have programming experience, it probably depends on what their previous experience was. @mimoo is familiar with Rust that has excellent errors, so he is easily disappointed, but until fairly recently C or Java compilers also had bad error messages (Clang was a bit help in moving the status quo).
The OCaml compiler errors have also improved a lot. Syntax error messages are still disappointing. For typing errors, my feeling is that the bad errors come with the most complex language features, and that some projects have gone overboard with these features in a way that hurts usability, but for mundane programming I find the errors in fact reasonable.
Summary; I certainly agree that error messages are important and I've worked on improving them, but I would not list them as a "main reason" to give up on the language.

2. Number of resources. Maybe, and this is an issue that is hard to solve by itself. I wish the OCaml community had stronger communication habits, people writing blog posts with cute examples of using their favorite library and what not. I'm not sure how to improve this -- besides generally making the language better so that more people join naturally.

3. Tooling.
Personally I don't have a problem with opam files, which I find relatively straightforward, or opam usage that is relatively well-documented in my experience. On the other hand, I have come to dislike the global-switch workflow: I think we should have one local switch for each development project, with caching to make this pleasant. (Yes, just like esy.) @dra27's work on relocatability is a major step in doing this "the right way", and I wish other people also considered it a high-priority project :-)
I agree that the Dune documentation is disappointing (it's just hard to find information there), and I think that the tool would need more usability work. On the other hand, I would rather expect beginners to start with relatively simple Dune files, and those are okay. Onboarding OCaml newcomers directly with a large, complex project is probably more difficult, but I never had this experience so I cannot tell.

Among the other things mentioned in the thread, I agree that `deriving` would be nice, or... maybe it's possible to add enough runtime type information in values that we can do a decent job of printing them for debugging. (I'm told that @let-def worked on something similar at some point.) The problem with `deriving` is  that it's fairly difficult to specify in a satisfying way. (It either feels like a simplistic ad-hoc solution or a complexity monster.) Modular implicits would help, but right now no one is actively working on them so we just have to be patient and look for volunteers I guess.

-------------------------

jhw | 2022-12-16 17:05:24 UTC | #16

[quote="jbeckford, post:13, topic:10958"]
So I‚Äôll be teaching a tribal-knowledge trick: looking at a library‚Äôs unit tests in its source code. *If only test code was automatically included in the documentation!*
[/quote]

I'm already on record in support of the observations @dbuenzli makes about the conceptual mess entailed by having both `opam list` and `ocamlfind list` produce mostly related (except where they are not) lists of conceptually different things called "packages"...

But @jbeckford points at another thing that I feel makes life difficult for OCaml users, the available unit test frameworks. The best one is probably Alcotest, but it's not great, and I haven't adopted it myself yet. Still using OUnit, which I also do not love very much.

At my day job, we work mainly in C++ and the available unit test frameworks there are, well, better. My favorite is [Catch2](https://github.com/catchorg/Catch2), but even the more popular one from G* has substantially better ergonomics than all of the available frameworks for OCaml.

I'm not sure what it is about OCaml that makes it hard to design a good unit test framework. Lack of good hygienic macros in the core compiler toolchain and standard library? No language support for polymorphic overloading? Combination of both? Other factors? No idea.

But if we're collecting reasons for people to grind their teeth on encountering OCaml, I'd have to put the unit test frameworks near the top of the list.

-------------------------

Jon_Harrop | 2022-12-26 19:24:47 UTC | #17

* Multiple personalities. Bytecode or Native code? Batteries or Base? Lwt or Async?
* Dead packages. Many (most?) Opam packages appear to be dead but there's no way to tell which are thriving and which are dead. For example, lablgtk3's own entry-level sample dies with a seg fault on Mac OS, lablgtk2 installs via Opam but isn't recognised as a package by Dune, labltk's canvas demo produces a blank window instead of the shapes it is supposed to.
* Syntax. All of this weird `[%%deriving show]` stuff is fine for experts but not ideal for newcomers trying to print some value of some type for debugging purposes.
* Installation is a hurdle for newcomers. Why have errors like `Error: Library "cohttp-lwt-unix" not found` when you can just install the library for the user? Took me an hour to get a barebones setup working with VSCode this week. If a website offered an OCaml IDE with persistent store you could just log on and start working. Better yet, integrate HTML, graphing and charting and we can have a nice technical computing environment.
* Lack of core functionality either entirely (like generic printing, generic sets and maps) or out-of-the-box (read the lines in a file). Stdlib improvements would help a bit but polymorphic equality, comparison and hashing are fundamentally broken and functors are a heavy solution.
* Opam and Dune could be easier to use. Why must I `opam init` by hand? Why must I repeatedly update my terminal's opam environment with `eval $(opam env)` by hand? Why does Dune create a behemoth multidirectory bin+lib scaffold by default when 99% of the time I just want 'Hello world'?
* Gotchas. I just tried extending the `String` module in a vanilla dune project and got circular module references that I couldn't figure out how to fix so I gave up. I used to do that all the time.

As an exercise, consider a pseudocode program like:

    data = [[1,2,3],[4,5,6],[7,8,9]]
    print data

How is this written in OCaml? First you have to install a package to get a second-rate `print` but there's no GUI so you use the CLI:

    opam install ppx_deriving

Then you have to figure out the necessary incantation in another syntax that requires a specific structure for which there is no editor tooling or GUI:

    (executable
     (public_name foo)
     (name foo)
     (preprocess (pps ppx_deriving.show ppx_deriving.ord))
     (libraries ))

Now we're ready to start coding but we must remember OCaml uses `;` separators instead of `,` like everyone else and we can use `in` or `;;` for entirely unclear reasons:

    let data = [[1;2;3];[4;5;6];[7;8;9]] in

Now we find the function to print is in another module, we must add `\n` ourselves, don't forget to flush with `%!` and we'll need to Google the insane inline PPX syntax required to print something:

    Printf.printf "%s\n%!" ([%derive.show: int list list] data)

I don't want to create a big temporary string though so I do:

    let () = Format.printf "%a\n%!" [%derive.pp: int list list] data

But that doesn't work and I cannot figure out how to fix it.

-------------------------

alan | 2022-12-16 18:16:49 UTC | #18

The OCaml toplevel will print the results of expressions, so the printing functionality already seems to be possible. I wonder what's preventing a polymorphic "show" function that converts a value to how it would appear as a toplevel result?

-------------------------

octachron | 2022-12-16 18:33:19 UTC | #19

Types don't exist at runtime in OCaml. A function that prints a value according to its type will never be possible in OCaml by design. The REPL is a different matter since the REPL can inspect the environment of the code it is executing and use the type information it has available at hand to implement some basic printing.

-------------------------

alan | 2022-12-16 18:36:56 UTC | #20

Ah, silly me. I forgot that types are erased, so there's no way of distinguishing between `[]`, `0`, and `None`, or `{ x = 0 }` and `Some 0`...

-------------------------

dbuenzli | 2022-12-16 23:18:38 UTC | #21

[quote="jbeckford, post:13, topic:10958"]
* How to fix `Unbound module XXX`. *Which is related to ‚Ä¶*
* What `(libraries xxx)` corresponds to what Opam package.
[/quote]

Note that even though it wasn't properly designed for that, the `omod` command line tool that comes up with [`omod`](https://erratique.ch/software/omod) (a toplevel helper to load what you want by module name rather than by library name which I find more natural) can help answering these questions ‚Äì though it reports them at a lower level. For example: 

```
> omod cobj Misc
Misc 9d0e49da1703d17dc3043e52bca13fe5 /Users/dbuenzli/.opam/4.14.0/lib/ocaml/compiler-libs/misc.cmi
Misc 9d0e49da1703d17dc3043e52bca13fe5 /Users/dbuenzli/.opam/4.14.0/lib/ocaml/compiler-libs/misc.cmx
Misc 9d0e49da1703d17dc3043e52bca13fe5 /Users/dbuenzli/.opam/4.14.0/lib/ocaml/compiler-libs/ocamlcommon.cma
Misc 9d0e49da1703d17dc3043e52bca13fe5 /Users/dbuenzli/.opam/4.14.0/lib/ocaml/compiler-libs/ocamlcommon.cmxa
```

Since nowadays a library `foo` defined in an opam `pkg` is most of the time installed as `$(opam var lib)/pkg/foo/foo.cm[x]a` you should be able to infer the library name and opam package of a given module name (more precisely of a given [compilation unit name](https://v2.ocaml.org/manual/compunit.html#s:compilation-units))

But, as the example above shows, that's not always the case.

-------------------------

jbeckford | 2022-12-17 00:12:56 UTC | #22

[quote="dbuenzli, post:21, topic:10958"]
the `omod` command line tool that comes up with [`omod` ](https://erratique.ch/software/omod) (a toplevel helper to load what you want by module name rather than by library name which I find more natural) can help answering these questions
[/quote]

Wow. That is a very useful tool.

-------------------------

kit-ty-kate | 2022-12-17 01:55:02 UTC | #23

[quote="Jon_Harrop, post:17, topic:10958"]
Why must I `opam init` by hand?
[/quote]

I agree calling `opam init` by hand it quite annoying for newcomers. Unless I missed the ticket I guess this is not a thing because nobody ever thought of opening a feature request for this. I opened one here: [https://github.com/ocaml/opam/issues/5395](https://github.com/ocaml/opam/issues/5395). Maybe there are good reasons for not doing it, i don't know, but if there are they'll be discussed there at least.

[quote="Jon_Harrop, post:17, topic:10958"]
Why must I repeatedly update my terminal‚Äôs opam environment by hand?
[/quote]

That shouldn't be the case. My guess why you think that is that you didn't accept that opam modifies your shell config files during your first `opam init`. No program can automagically modifying the environment without modifying your shell config, so that's why it is needed in the first place.
```
$ opam init

<><> Fetching repository information ><><><><><><><><><><><><><><><><><><><><><>
[default] Initialised

<><> Required setup - please read <><><><><><><><><><><><><><><><><><><><><><><>

  In normal operation, opam only alters files within ~/.opam.

  However, to best integrate with your system, some environment variables
  should be set. If you allow it to, this initialisation step will update
  your bash configuration by adding the following line to ~/.profile:

    test -r /home/opam/.opam/opam-init/init.sh && . /home/opam/.opam/opam-init/init.sh > /dev/null 2> /dev/null || true

  You can always re-run this setup with 'opam init' later.

Do you want opam to configure bash?
  1. Yes, update ~/.profile
  2. Yes, but don't setup any hooks. You'll have to run eval $(opam env) whenever you change your current 'opam switch'
  3. Select a different shell
  4. Specify another config file to update instead
> 5. No, I'll remember to run eval $(opam env) when I need opam

[1/2/3/4/5] 5

[...]
```

Now there could be improvement to the way we display this information. If anyone have ideas, you're most welcome to open a feature request on [our bugtracker](https://github.com/ocaml/opam/issues).

-------------------------

Chet_Murthy | 2022-12-17 02:36:21 UTC | #24

[quote="Jon_Harrop, post:17, topic:10958"]
Why must I repeatedly update my terminal‚Äôs opam environment by hand?
[/quote]

First, before I write anything else, I don't find this to be problematic.  I have a bash function:
```
function refresh_switch {
 eval $(opam env)
}
```
so I can do
```
opam switch 5.0.0
refresh_switch
```
and everything is straight and clean.  I could combine the two ... which leads now to an observation.

There's this thing called "Anaconda" (aka "conda").  Maybe some readers know of it.  It's an environment that started off as "better than virtualenv+pip for python" but evolved into a sort of crazy-on-steroids package-manager for data science.  It's .... well, it's better than building packages by hand, but pretty wild-west and lots of things break.  But for your average chemist/physicist, it's a *lifesaver*, b/c really, building stuff from source is *death*.  Hot flaming death.

Where am I going with this ....

Anaconda support multiple "environments" (a lot like switches) and you can switch really effortlessly.  To switch to an environment named "Goo" you do
```
conda activate Goo
```
and all the environment variables get set, etc, etc, etc.

How does it accomplish this?  Well, *obviously* "conda" is a bash function.  And there are versions of it for other shells.  So once you see that, it's obvious that you can put all the smarts into a single command, and no need to do any `eval argle bargle` trickery.

OK.  So to sum up, there's a way to avoid the (to me minor) extra steps.  It involves some extra work by the opam developers.  Me, I think I'd rather they spend their time on other things, and this particular thing is something that a reasonably experienced BASH developer could knock out as a contribution.

Anyway, my 2c

-------------------------

dbuenzli | 2022-12-17 09:03:27 UTC | #25

[quote="jbeckford, post:22, topic:10958, full:true"]
[quote="dbuenzli, post:21, topic:10958"]
the `omod` command line tool that comes up with [`omod` ](https://erratique.ch/software/omod) (a toplevel helper to load what you want by module name rather than by library name which I find more natural) can help answering these questions
[/quote]

Wow. That is a very useful tool.
[/quote]

It was written to provide a constructive proof that one didn't need additional metadata (i.e. `ocamlfind` `META` files)  in order to link libraries or use a given compilation unit since the whole dependency graph is already written on disk in the compilation artefacts. 

`ocamlfind`'s `META` files are more powerful but 99% of time this power is not used and `omod` will do. IIRC I found a single, rather rare, pattern on which it fails (it was an odd thing made by the `digestif` package, which entails an implicit dependency on a C stub that cannot be discovered).

As a side effect it shows that there is a lot of untapped user experience improvements available upstream ‚Äì e.g. autoloading modules on first use in `ocaml`. But it would need more user experience thinking upstream, rather than the current feature-based mindset. Workflows, not features.

Ultimately I think this is the biggest hurdle facing OCaml: it will be difficult to compete with languages that take user experience seriously. And that doesn't mean you need `cargo` upstream as people seem to think nowadays, a simple notion of library would already go a long way. It's rather a constellation of details that support established development and software life-cycles practices (deprecation, debugging, profiling, testing, etc.) in which the compiler should be on the front line to help but is more often missing in action at the moment.

-------------------------

lukstafi | 2022-12-17 10:00:48 UTC | #26

For what it's worth, I think of the point that Jon Harrop was making a few times over the years:
the OCaml's place in the language design space eschews the various forms of overloading: overloaded functions, overloaded operators, all-computation-is-methods OOP languages, type classes. This makes OCaml's code more understandable, which is a downside because it makes it harder to write code that one doesn't understand.

-------------------------

dra27 | 2022-12-17 11:44:44 UTC | #27

[quote="kit-ty-kate, post:23, topic:10958"]
No program can automagically modifying the environment without modifying your shell config, so that‚Äôs why it is needed in the first place.
[/quote]

No _Unix_ program üôÇ As it happens, the Windows version of opam 2.2 does this automatically without needing any shell configuration both in Cmd and PowerShell (unless you explicitly configure `opam` not to do it).

-------------------------

Jon_Harrop | 2022-12-17 11:51:38 UTC | #28

Yes and no. I'd say that modern OCaml is now trying to eschew overloading today but it has the legacy of type unsafe polymorphic equality, comparison and hashing and handy things like `List.assoc` and `Hashtbl` built atop them. I'm guessing those aren't going away for practical reasons?

The problem with `[%derive.show: t]` and friends is that they accept types and not values. That's a problem because it requires the type to be written somewhere in a language where not having to write out types is a core feature. The place where that chafes the most is tuples because they are almost always inferred. In that case the resulting code was worse than using combinators:

    Print.(list (list int)) data

As you say, having them accept values would go against the spirit of modern OCaml.

FWIW, I'm curious about the opposite language design. What if a language had ints, floats, chars, tuples, strings, arrays, sets and maps with polymorphic equality, comparison, hashing, pretty printing and serialization built-in? Not academically interesting but perhaps very pragmatic.

-------------------------

Jon_Harrop | 2022-12-17 15:42:40 UTC | #29

LÃ∂aÃ∂cÃ∂kÃ∂ Ã∂oÃ∂fÃ∂ Ã∂mÃ∂uÃ∂lÃ∂tÃ∂iÃ∂cÃ∂oÃ∂rÃ∂eÃ∂ Ã∂sÃ∂uÃ∂pÃ∂pÃ∂oÃ∂rÃ∂tÃ∂

-------------------------

cdaringe | 2022-12-17 18:18:06 UTC | #30

Builtin in derivation that is delightful to use‚Äîyes! ppx_deriving baked in, additional goodies for making printing/formatting simpler. The second for me, debugging.

I have influence in technology selections periodically at my company. I cannot sensibly offer ocaml as a contender in good faith without these. To offer this toolkit would reveal my bias, not my good faith argument that it‚Äôs a sensible engineering decision, knowing the hurdles to productivity.

-------------------------

bluddy | 2022-12-17 21:30:24 UTC | #31

[quote="Jon_Harrop, post:28, topic:10958"]
The problem with `[%derive.show: t]` and friends is that they accept types and not values.
[/quote]

The issue is that ppx doesn't have access to the typechecker's output. This is one of the major things that distinguish a macro-based system like Rust's from ppx.

-------------------------

Chet_Murthy | 2022-12-17 22:16:52 UTC | #32

[quote="bluddy, post:31, topic:10958"]
The issue is that ppx doesn‚Äôt have access to the typechecker‚Äôs output. This is one of the major things that distinguish a macro-based system like Rust‚Äôs from ppx.
[/quote]

I don't think that's right.  Or, more precisely, I don't think that that's correct in a surface reading.  Rust's macro system is actually much weaker than PPX.  Much, much weaker.  What makes it work, is that you combine it with traits/modular-implicits.  That's where the type-system access comes from.

The two combined, effectively, yes, gives macros access to the type-checker.

-------------------------

yawaramin | 2022-12-18 03:14:53 UTC | #33

[quote="gasche, post:15, topic:10958"]
My experience with students without any programming background is that they don‚Äôt real error messages at all ‚Äì in any language ‚Äì they are just interested in the source location.
[/quote]

In my experience programming in several languages, I usually look for particular words in the error messages, looking for the signal in the noise. Here's a typical type error:

```text
File "./test.ml", line 1, characters 12-16:
1 | let x = 1 + true
                ^^^^
Error: This expression has type bool but an expression was expected of type
         int
```

Note: the only colouring used in this error message is for the `^^^^` and the word `Error`. Even leaving that aside, the layout of the message is not great. I need to scan through the entire message to figure out which types are mismatching. Imho if we printed a simple diff style it would be much more easily scannable:

```text
Error: type mismatch
File: ./test.ml:1:12-16
1 | let x = 1 + true
                ^^^^
Expected:
  int
Actual:
  bool
```

From there we can actually talk about more sophisticated diffing capabilities for complex types.

> some projects have gone overboard with these features in a way that hurts usability

Perhaps, but even a complex type mismatch error may be improved by a careful layout and diffing to make it easier for the human reader.

-------------------------

dogfishbar | 2022-12-18 05:08:01 UTC | #34

I hope this isn't off topic.

I've been using OCaml in an Honors CS1 course since 2014. My dept. is unlikely to continue using OCaml in that course now that I've finished teaching it, even though OCaml is truly great for teaching once you overcome the barriers-to-entry. The stronger students in the Honors course love OCaml but it doesn't resonate as well for the average student who is wondering why we aren't using resume-friendly Python like their friends. Some grudgingly accept learning OCaml in part because they see that it's used in prestigious schools like Cornell & Harvard. If Cornell & Harvard stopped using OCaml enrollment in my Honors course would drop.

Installation of OCaml and graphics libraries is a very significant problem. Wealthier students have Macs so they have less trouble but many students have inexpensive Windows systems and installation issues for Windows students have been a show-stopper for many of them.
The situation has been improving but not enough to win over enough students and I've made no headway in recruiting colleagues to continue using OCaml in Honors CS1. It's a bummer. If OCaml had a one-click install teaching environment things might be different.

-------------------------

alan | 2022-12-18 05:30:18 UTC | #35

[quote="yawaramin, post:33, topic:10958"]
From there we can actually talk about more sophisticated diffing capabilities for complex types.
[/quote]

http://www.mlton.org/guide/20201002/TypeChecking MLton has great type errors that put brackets around the parts of the type that are different. (I'm not sure if I agree with its approach of replacing the parts of the type that are the same with underscores, because seeing the full type helps me figure out where I went wrong if the type or expression is complicated.)

-------------------------

ahem | 2022-12-18 06:07:12 UTC | #36

For this particular error, I think it would be nice (maybe with additional compiler flag) to see a (truncated?) chain of how both the "actual" and "expected" were inferred, because sometimes the mistake isn't at that particular location... i.e. actual type is "x" because it was inferred from usage on line ### to be "y", which in turn was inferred from line ### to be "z"... (and similarly for the expected type)

-------------------------

gasche | 2022-12-18 06:10:47 UTC | #37

Well, have you considered proposing your preferred error format as a PR to the OCaml compiler?

-------------------------

orbitz | 2022-12-18 07:02:11 UTC | #38

I know this thread is about improvements, but I would like to give thanks to the compiler team for the improvements in type errors over the years.  I notice it especially in terms of polymorphic variants.  It used to be that you'd just be told the two variants don't match, and now it tells you what's missing.  Other messages have improved a lot over the years too.  There is always room for improvement, but error messages are really a lot better now.

-------------------------

bluddy | 2022-12-18 07:34:11 UTC | #39

Looking at some Rust macro code, you're absolutely right. I thought their macros did more stuff under the hood, but in fact many of them serve as efficient convenience functions, and Traits do most of the heavy lifting.

-------------------------

yawaramin | 2022-12-18 07:48:45 UTC | #40

I've been playing around with it locally but haven't had time to dig deeper:

```
diff --git a/typing/printtyp.ml b/typing/printtyp.ml
index b0bf36ceb..48e428d3a 100644
--- a/typing/printtyp.ml
+++ b/typing/printtyp.ml
@@ -2346,7 +2346,7 @@ let head_error_printer mode txt_got txt_but = function
   | None -> ignore
   | Some d ->
       let d = Errortrace.map_diff (trees_of_type_expansion mode) d in
-      dprintf "%t@;<1 2>%a@ %t@;<1 2>%a"
+      dprintf "@[%t:@]\n       @[%a@]\n@[%t:@]@[%a@]"
         txt_got type_expansion d.Errortrace.got
         txt_but type_expansion d.Errortrace.expected
```

Will try to do so over the holidays.

-------------------------

Chet_Murthy | 2022-12-18 08:28:25 UTC | #41

Doesn't WSL solve these graphics issues?  I thought you could run arbitrary Linux binaries on that ?

-------------------------

benjamin-thomas | 2022-12-18 09:50:58 UTC | #42

I'm not sure anything actionable will come of this thread but I'll give my two cents :)

For me the main thing which I find lacking and could be improved is **documentation**.

Ocaml is different enough that it's quite easy to get lost at the beginning. If you want to dedicate, let's say a morning, to explore the language knowing nothing about it, you'll probably fail. Which is not the case for other languages.

I'll give an example of a bad documentation experience:

You want to find out how dealing with SQL would be in Ocaml, you find about [caqti](https://github.com/paurkedal/ocaml-caqti).

You go to its repo, the example doesn't actually contain any CRUD operations :(

You look for examples, see that the `README` points to an article/tutorial on Medium, which talks about `jbuilder` which then leads you into a rabbit hole, so you waste time trying to understand what this tool was and how it is related to your current problem of trying to make your demo work.

I'm interested in Ocaml enough to push through but I can easily imagine some people dropping out at this stage, which is unfortunate.

I'm not picking on `caqti` btw, it's just a random example. I've also stumbled upon certain projects with absolutely no documentation - such a shame.

Of course, we can go read the source code, etc. But my main point is more documentation = less friction = better :)

IMO, the Ocaml community should take inspiration from Elixir, for which its tool-chain enables generating documentation such as this:

- [Documentation for an SQL library](https://hexdocs.pm/ecto/getting-started.html)
   - any documented library looks the same since it's handled by the tool chain
   - [The documentation's source is here](https://github.com/elixir-ecto/ecto/blob/master/guides/introduction/Getting%20Started.md)
    - there's a nice "View Source" link at the top of any page.
- [Documentation for a specific module](https://hexdocs.pm/ecto/Ecto.Query.html)
  - [The documentation's source of this specific module](https://github.com/elixir-ecto/ecto/blob/v3.9.2/lib/ecto/query.ex#L12)

I'm not quite sure what the documentation story of Ocaml is, and I understand the tooling keeps on improving.

Overall, I'm very happy with Ocaml, but if documentation (and maybe the related tooling) could be improved it'd be that much better!

-------------------------

dogfishbar | 2022-12-18 13:31:18 UTC | #43

Yes, WSL helps. But WSL2 uses a hypervisor for the installed VM (running Ubuntu), and assigns it its own IP address. If you install an X11 server like VcXsrc on the Windows side and hope to use it to render images from code running on Ubuntu, you're going to run into problems with the default settings of Windows Defender Firewall and/or with their McAfee virus software. I got this to work on their systems by turning off WDF and McAfee on student's computers. It wasn't great. The IP address also has to be explicitly set.
This can be made to work. But they find it off-putting and their non-Honors roommate clicked a single button on python.org and everything just worked. (Granted sans student-friendly graphics libraries. Racket has a better story here, but I definitely don't want to teach Racket, I want to introduce them to coding in OCaml.)

-------------------------

lukstafi | 2022-12-18 13:51:57 UTC | #44

Maybe I'm confused, but the latest version of WLS2 might support X11 out of the box. [WSL tutorial GUI apps](https://learn.microsoft.com/en-us/windows/wsl/tutorials/gui-apps)

-------------------------

gasche | 2022-12-18 14:14:52 UTC | #45

@benjamin-thomas have you given this feedback to the Caqti authors, for example by opening an issue on the caqti issue tracker? (cc @paurkedal the Caqti author)

-------------------------

bluddy | 2022-12-18 14:28:38 UTC | #46

This is correct. It's still using X11 (and is thus somewhat inefficient), but it does so natively.

-------------------------

paurkedal | 2022-12-18 14:38:21 UTC | #47

As the maintainer of Caqti, I was very happy about the Medium article when it came, but it is somewhat outdated now.  I agree, a new or rewrite of the tutorial-style documentation is needed.  Not sure if you saw it, but there is a CRUD minus the "D" example, the [bikereg](https://github.com/paurkedal/ocaml-caqti/blob/master/examples/bikereg.ml), while the code in the README is merely to show how to use Caqti under utop.  Yes, the organization of the documentation, starting at the README, needs work too.

-------------------------

benjamin-thomas | 2022-12-18 15:17:31 UTC | #48

No I haven't :)

As I said this isn't specific to caqti. I just wanted to communicate that having tooling specifically designed to generate good documentation would probably encourage package maintainers to do more with minimal effort, and help make Ocaml look more attractive to potential new users.

[quote="paurkedal, post:47, topic:10958"]
Not sure if you saw it, but there is a CRUD minus the ‚ÄúD‚Äù example, the [bikereg](https://github.com/paurkedal/ocaml-caqti/blob/master/examples/bikereg.ml), while the code in the README is merely to show how to use Caqti under utop
[/quote]

Yes I did see it, this morning actually. I've finally been able to get a working demo which I was very happy with. :)

I had to work on Ocaml for a few weeks, to get to this stage though.

I could contrast this with my Clojure experience, for instance, and this [SQL library](https://github.com/seancorfield/honeysql). Knowing nothing about Clojure (or LISP), I got a basic demo going yesterday, in just a few hours.

So of course,  I know I'm comparing apples and oranges here. But still, I do want to make note of the contrast.

[quote="paurkedal, post:47, topic:10958"]
As the maintainer of Caqti, I was very happy about the Medium article when it came
[/quote]

I'll keep this in mind for later.

-------------------------

Chet_Murthy | 2022-12-18 16:23:42 UTC | #49

I mean this only somewaht snarkily, but ..... perhaps these Windows-using students ought to learn how to install Linux on their machines ?  Back in the 90s that was sort of a rite of passage for university students: you get a doorstop machine from somewhere, install Linux on it, and it becomes your "school machine".  It would teach them skills in sysadmin and all-around operations that are valuable to have for all software engineers.

-------------------------

Chet_Murthy | 2022-12-18 18:56:03 UTC | #50

A  different answer:  these students need cheap laptops.  Maybe they should be buying Chromebooks instead of Windows laptops?  I use a <strike>$5000</strike> $500 Chromebook for almost all my development (and also movie-watching).  It's perfectly cromulent. HP x360 14c (4-core i5, 8GB mem, 256GB SSD).  It's got a Linux container, and you can run X-windows apps in there by default.

ETA: Whups!  $500.  Five Hundred.  Sorry.

-------------------------

yawaramin | 2022-12-18 16:50:36 UTC | #51

Answer to both questions from my personal experience as a university student: Windows is often unavoidable because other coursework uses software that specifically requires it. For example back when I was studying econometrics, our courses were using a software called [EViews](https://www.eviews.com/download/student12/) which as you can see is Windows or Mac only.

-------------------------

Chet_Murthy | 2022-12-18 17:18:35 UTC | #52

There's dual-boot.  Also Vmware is free.  Lots of ways to install Linux on a Windows box.  The key thing is: it takes some attention and motivation.  But kids used to do it all the time back in the 90s when computers weren't cheap and you had to make do with what you found.

-------------------------

yawaramin | 2022-12-18 17:47:47 UTC | #53

Dual-boot can be pretty tricky to set up and VMWare would not offer a great workflow (developing in a virtual machine). Again, we are contrasting with one-click installs here like Python. Sure, back in the old days we were doing things the hard way but it's just surprising that after more than a decade, we can't do much better.

-------------------------

Chet_Murthy | 2022-12-18 17:54:32 UTC | #54

Every time this comes up (and it comes up at least once a year), I ask the obvious question: where are the hard-core Windows users who could do this work ?  And it seems that they do not exist.  How did Python get to where it had nice Windows support ?  Maybe it's worth looking into the history there ?

B/c if the answer is "UNIX jocks who never used Winders except under duress, need to hold their noses and touch that feculent pile of bits long enough to do this work" .... well, that's not really going to work.

-------------------------

Chet_Murthy | 2022-12-18 17:58:09 UTC | #55

Yawar, you mentioned that you used Windows in college.  Why did you stop using it?

-------------------------

jbeckford | 2022-12-18 18:45:47 UTC | #56

[quote="Chet_Murthy, post:54, topic:10958"]
where are the hard-core Windows users who could do this work ?
[/quote]

Wrong question for two reasons:
1. You don't need hard-core Windows users. I'm not; I'm a generalist. Yet that still hasn't stopped me from contributing to Windows.
2. The question presumes that *nix users can't do anything.

What can you, as a *nix dev, do today?
1. I released [setup-dkml](https://github.com/diskuv/dkml-workflows#readme) a while ago; among other things, it does CI testing of OCaml packages on Windows using the Microsoft compiler. There are hundreds of critical packages that are waiting for your PRs to make sure they compile successfully on native Windows.
2. Windows does not have hardcoded paths like `/usr/bin` to install software; every Windows machine and user can set up their own paths. That means today that OCaml code has to be compiled on Windows PC during the install, contributing to a poor install experience. @dra27 has stepped up and is doing the work to get a relocatable OCaml compiler ... that is the huge first step. But `ocamlc -config` is probably just the start of hardcoded paths in the OCaml ecosystem. *nix devs could be auditing other OCaml packages and removing the hardcoded paths today.
3. If you work for a company, ask them to contribute to [OCSF](http://ocaml-sf.org/). That is the easiest vehicle to get critical Windows work funded.

I can probably come up with more things that can be done; message me privately if you can't find an area to help.

And when proficient OCaml-ers complain about Windows, and yet aren't doing anything to improve Windows, please refer them to this post.

-------------------------

Kakadu | 2022-12-18 18:54:27 UTC | #57

In general, I think that we should [write something like this](https://itvision.altervista.org/why.linux.is.not.ready.for.the.desktop.current.html) to check that we are moving into the right direction about usability.


[quote="Chet_Murthy, post:50, topic:10958"]
A different answer: these students need cheap laptops. Maybe they should be buying Chromebooks instead of Windows laptops? I use a $5000 Chromebook for almost all my development (and also movie-watching). It‚Äôs perfectly cromulent.
[/quote]

$5000 is an opposite of being cheap

-------------------------

Chet_Murthy | 2022-12-18 18:55:29 UTC | #58

OOPS.  $500.  Five Hundred.  Sorry.

-------------------------

Chet_Murthy | 2022-12-18 19:01:01 UTC | #59

[quote="jbeckford, post:56, topic:10958"]
The question presumes that *nix users can‚Äôt do anything.
[/quote]

My question made a different assumption: Unix jocks gain literally zero benefit from Windows support, b/c we never use Windows.  I have run Windows in VMWare in order to run my company's VPN, and sometimes to run Lotus Notes.  That's it.  Otherwise, it was Linux (and before that, AIX).  Why would I want to learn a thing about Windows -- enough to even the simplest thing ?  That effort and learning can go to learning more about Unix and doing a better job there.

It really does come back to having committed, really commiited Windows users, who want to see OCaml spread on the Windows platform. That's what I mean by hard-core: people who will do hard work to improve OCaml on their platform.

When I worked for IBM, I was the DB2-Perl maintainer for a number of years: I debugging various problems with that interface and added new DB2-specific function a number of times.  Without people in IBM doing that work, it wouldn't have gotten done.  And you can't expect somebody who works with Oracle every day to do it, either, since (a) they derive zero benefit, and (b) they don't have the experience and knowledge to do a good job.

-------------------------

Frederic_Loyer | 2022-12-18 20:55:49 UTC | #60

Since I am on Windows, I have some platform specific issues. Opam packages are compiled from sources, but the Windows ecosystem makes it harder to assemble different projects (if only there was unique "apt-get source" command).

Let's take Gtk2 and its lablgtk binding. I have installed mingw-w64-x86_64-gtk2 (on MSYS2 with pacman), but "opam install lablgtk" fails to find the "pkg-config" helper. And I can't find it to resolve a PATH issue. (And I don't know if the Diskuv environment, based on VS is compatible with Gtk2 based on MSYS2).

Then, having a fully integrated environnement (Java and its Swing GUI) makes things far easier.

-------------------------

yawaramin | 2022-12-18 21:25:22 UTC | #61

Just curious, are you referring to installing GTK from these instructions? https://www.gtk.org/docs/installations/windows#using-gtk-from-msys2-packages

-------------------------

jbeckford | 2022-12-18 21:30:54 UTC | #62

[quote="Frederic_Loyer, post:60, topic:10958"]
Let‚Äôs take Gtk2 and its lablgtk binding. I have installed mingw-w64-x86_64-gtk2 (on MSYS2 with pacman), but ‚Äúopam install lablgtk‚Äù fails to find the ‚Äúpkg-config‚Äù helper. And I can‚Äôt find it to resolve a PATH issue. (And I don‚Äôt know if the Diskuv environment, based on VS is compatible with Gtk2 based on MSYS2).
[/quote]

opam 2.2 will extend depexts to both Cygwin and MSYS2 (pacman). It sounds like lablgtk will need a little `.opam` tweak to use the provided `pkg-config` after it is released. For Diskuv OCaml, pacman will be using CLANG64 which (today) is the closest we can get to proper Microsoft compatibility.

[quote="Chet_Murthy, post:59, topic:10958"]
That effort and learning can go to learning more about Unix and doing a better job there.
[/quote]

Of course. But you don't need to be a hard-core Windows user (the committed, really commiited Windows users you mention) to tweak your `.opam` or CI to support Windows. The benefit that accrues to you is a potential doubling of your users. That is no small thing.

-------------------------

Frederic_Loyer | 2022-12-18 21:33:48 UTC | #63

Yes, and with gtk2 instead of gtk3, since lablgtk is a Gtk2 binding. But Gtk3 is also installed.

-------------------------

Chet_Murthy | 2022-12-18 22:19:10 UTC | #64

[quote="jbeckford, post:62, topic:10958"]
But you don‚Äôt need to be a hard-core Windows user (the committed, really commiited Windows users you mention) to tweak your `.opam` or CI to support Windows.
[/quote]

So I tried that with the Mac.  There are two different Mac distros that opam is starting to support, and here's what I found:

1. if I do nothing, users whine because the packages I release don't support the Mac

2. if I ask them for help in getting things to work, they're too inexperienced or lazy to do the work.  I am reminded of the early days of open-source, when the admonition RTFSC was relevant.   Or "Use the source, Luke".  People who don't know how to read and run Makefiles.  The Lazy.

    There's nothing wrong with being lazy.   But if you're lazy, then don't expect other people to do your work for you, unpaid.  Offer them a fair wage for their hours of work.  Or, y'know, get a Linux box.

3. When I figured out how to make one of the two distros work, people continued to complain that the *other* distro didn't work.  **Jesus, just use the Mac distro that does work, what's so hard about that?**

4. And thru it all, when stuff broke, I had no way of debugging, b/c  I don't have a Mac, don't  have access to a Mac, and so cannot actually debug a build-failure.

All of that will get *worse* for WIndows, b/c at least MacOS is UNIX; Windows is some completely other thing.

P.S. the packages in question were literally "conf-perl-*" packages -- that is, packages whose content was "install this pretty well-known Perl module".  So it ain't like what I needed help with was rocket science, and yet, Mac users who used distro X didn't know how to do that for distro X.  I mean, they chose the bloody platform, you'd think they'd know how to actually use the thing.

-------------------------

dogfishbar | 2022-12-18 22:24:52 UTC | #65

Yes, in that course we do cover the unix command shell. Students who know the command shell are not helpless when things go wrong.

-------------------------

jbeckford | 2022-12-18 22:46:02 UTC | #66

That's fair. If you or any other package maintainer needs help getting your package to work with Windows (after the upcoming opam 2.2 is released), perhaps start a thread on `discuss.ocaml.org` asking for help.

-------------------------

Chet_Murthy | 2022-12-18 23:01:36 UTC | #67

Thank you for this!  I will keep your offer in mind.   This was all I wanted: somebody who wanted something to work on the Mac, and was willing to do the Mac-platform-specific bits (which, as I described, were completely unrelated to the code of my packages).

-------------------------

yawaramin | 2022-12-19 00:50:33 UTC | #68

[quote="Chet_Murthy, post:64, topic:10958"]
There‚Äôs nothing wrong with being lazy. But if you‚Äôre lazy, then don‚Äôt expect other people to do your work for you, unpaid. Offer them a fair wage for their hours of work. Or, y‚Äôknow, get a Linux box.
[/quote]

Well, yes. Ultimately most things have a limited number of root causes. Usually lack of resources. But it helps to identify what exactly are the things that are missing before we try to identify where exactly to spend the resources. In our case we know the root cause is 'no one has put up enough money to get anyone to seriously work on DX especially Windows'. And Jonah made a really good suggestion that people can contribute and pool funds with the OCSF. But we are trying to figure out 'what exactly would make the DX good especially on Windows'. It seems no one is quite sure yet.

-------------------------

Chet_Murthy | 2022-12-19 00:54:41 UTC | #69

[quote="yawaramin, post:68, topic:10958"]
It seems no one is quite sure yet.
[/quote]

I could be wrong about this, but: If there were sufficiently experienced and skilled Windows developers who used OCaml, then they could tell you what was wrong, what was needed.  That nobody really knows, means that nobody with that level of experience is actually using it on Windows.

-------------------------

bluddy | 2022-12-19 07:02:40 UTC | #70

This is becoming a discussion about Windows (and Mac) support. Nevertheless, the reality is that the majority of people in the world have Windows boxes. There are countless macs out there. Linux is just a teeny tiny fraction of the desktop and laptop market. If our community wants to grow, and especially if it wants to not disappear, it *has* to have good support for these operating systems. Fortunately, these things are progressing.

[quote="Chet_Murthy, post:69, topic:10958"]
If there were sufficiently experienced and skilled Windows developers who used OCaml, then they could tell you what was wrong, what was needed. That nobody really knows, means that nobody with that level of experience is actually using it on Windows.
[/quote]

Yes -- we're stuck in a chicken-and-egg problem, because our support on Windows is so poor, that we have very few Windows developers. As our support for Windows improves, we'll get more of them, and they'll be able to help other people with similar issues. These are all feedback loops.

[quote="jbeckford, post:56, topic:10958"]
@dra27 has stepped up and is doing the work to get a relocatable OCaml compiler ‚Ä¶ that is the huge first step.
[/quote]

How far along are we on that path? @dra27 ?

-------------------------

mseri | 2022-12-19 08:14:37 UTC | #71

While we wait for an official answer, there was this talk recently: https://watch.ocaml.org/videos/watch/8c1c3fda-0106-4c7d-a794-33da7e758fee

-------------------------

emillon | 2022-12-19 10:06:57 UTC | #72

I just want to say thank you for this message @jbeckford, I'm fully behind this. Good windows support means that more people can use OCaml, which will ultimately benefit every platform. It's important to get out of the mindset that windows support is only the job of windows people.

-------------------------

dra27 | 2022-12-19 10:29:41 UTC | #73

[quote="bluddy, post:70, topic:10958"]
How far along are we on that path? @dra27 ?
[/quote]

Getting there! Partly, as noted in the Q&A in the talk (assuming that's on the video), getting OCaml 5.0 of the door was a bigger priority the last couple of months (and the COVID I caught at ICFP really hasn't helped!).

I'm feeling on track to have the OCaml PRs ready in plenty of time for 5.1's release cycle - before that, I intend to publish an opam-repository fork which can be used for testing it on the 4.08-5.0 versions demonstrated in the video (I only haven't done that because the caching mechanism used in September is slightly too liberal with its checks).

-------------------------

jonludlam | 2022-12-19 11:59:42 UTC | #74

We do have infrastructure for generating documentation from the source. As an example, from caqti itself, [some documentation for one if its modules](https://ocaml.org/p/caqti/1.9.0/doc/Caqti_error/index.html) which is derived from [the source](https://github.com/paurkedal/ocaml-caqti/blob/cba1047b9e318bc450be72ab9dfb302aac8e4a78/caqti/lib/caqti_error.mli). This is all generated automatically for any package in opam, via an ocurrent pipeline.

This is, of course, not at all adequate as you've pointed out -- there's no way to automate the writing of beginners guides, tutorials, examples and so on. What it _does_ mean is that when this is done, it will automatically be built and hosted in a central site, which will be improving as our infrastructure improves.

We're currently working on a feature where you'll be able to [jump to the source](https://github.com/ocaml/odoc/pull/909) (implementation, not interface) from the docs, and also we're working on [improved search](https://github.com/ocaml/odoc/issues/567), where we'll be ranking search results based on the uses in other code, so highly used types and values should appear first in search results.

I'm hopeful that these sorts of improvements will encourage library authors to write more documentation for their libraries! There is a lot of information on [the odoc website](https://ocaml.github.io/odoc/odoc_for_authors.html) to help people.

-------------------------

benjamin-thomas | 2022-12-19 15:47:17 UTC | #75

This looks fantastic @jonludlam!

Have you considered integrating a `doctest`-like feature (aka "testable examples") into `odoc`?

If documenting could be merged into one's (basic) testing workflow, I'm sure it would encourage even more adoption and usage.

Here are a few implementations of what I'm talking about:

- https://docs.python.org/3/library/doctest.html
- https://go.dev/blog/examples
- https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html
- https://hexdocs.pm/ex_unit/1.13/ExUnit.DocTest.html
- https://github.com/sol/doctest#readme

This feature/concept is integrated into the default Go, Rust and Elixir tool chains (not sure about Python which is were the idea came from years ago).

The doctest feature for Haskell is supported by the default vscode tooling and easily integrated into a `cabal` workflow. It's very nice to use, and looks like this:

This comment turns into executable code:
![image|535x168](upload://ullMjUh6ShhsBcurX5f34dG2ELY.png)

From the caller's perspective:
![image|605x259](upload://Dew74yN1ZMOjwhuNZSmjuTWQU4.png)
 
This is what happens if I change my function input and click "Refresh" (the feedback is instantaneous).
![image|530x176](upload://lBQXvAYp6rq8Qr2BFWhpyMOtYqY.png)

Or clear the line and let the tooling auto-fill the output by clicking on "Evaluate", similar to a `dune promote` workflow.
![image|525x159](upload://brJNlVz6GVG6UrdgMFqgp2S9ZUj.png)

-------------------------

jonludlam | 2022-12-19 16:24:01 UTC | #76

Yes! I fully agree that testable example stuff is essential. I made a PR to add mld support to mdx to do exactly this a while back, but I'm afraid I got a bit distracted from it and didn't get around to making the required changes: https://github.com/realworldocaml/mdx/pull/377 - the PR includes an example [here](https://github.com/jonludlam/mdx/blob/mld_support/test/bin/mdx-test/expect/simple-mld/test-case.mld) if you're interested in seeing what it looks like. It supports the dune 'promote' workflow, so you should be able to edit then `dune runtest; dune promote` to get the results corrected. I should get back to it!

-------------------------

mro | 2022-12-19 20:20:00 UTC | #77

[quote="bluddy, post:70, topic:10958"]
if our community wants to grow
[/quote]

does it?

I would rather see it sustain and thrive.

Excessive growth could be counterproductive.

-------------------------

talex5 | 2022-12-19 19:52:57 UTC | #78

[quote="jhw, post:16, topic:10958"]
But @jbeckford points at another thing that I feel makes life difficult for OCaml users, the available unit test frameworks. The best one is probably Alcotest, but it‚Äôs not great, and I haven‚Äôt adopted it myself yet. Still using OUnit, which I also do not love very much.
[/quote]

I've been using [MDX](https://github.com/realworldocaml/mdx) for tests recently. Most of Eio's tests are like this, for example:

https://github.com/ocaml-multicore/eio/blob/main/tests/condition.md

Some benefits:

1. You don't have to write printers for values, because you have a top-level environment with the types from the compiler.

2. This makes it easy to dump the whole output, rather than just probing a few properties.

3. The format encourages you to comment the test cases, group them under headings, etc.

4. If you change something in the code, it automatically generates a diff showing how the test output changes, and you can just choose to accept it (`dune runtest --autopromote`).

It has some problems too, though:

1. There's no support for skipping tests on certain platforms (e.g. for Windows-only tests, or skipping IPv6 tests on platforms without that).

2. No merlin or ocp-indent support when editing the files.

3. Hard to see output-so-far if a test hangs (have to hunt around in /tmp for the output file).

4. Everything runs as byte-code, so it won't find bugs specific to native code.

-------------------------

yawaramin | 2022-12-19 20:26:55 UTC | #79

Yes, it does. First, that is part of the OCSF mission statement: https://ocaml-sf.org/

> We collect donations from our sponsors, companies, entities or people interested in growing the OCaml programming language, and redistribute these resources to grow, support and strengthen the OCaml community.

Second, based on the last available survey results: https://docs.google.com/forms/d/1OZV7WCprDnouU-rIEuw-1lDTeXrH_naVlJ77ziXQJfg/viewanalytics#c21

The most voted-for responses for what the community wants the OCSF to work on, are all activities that would grow the community. A couple of examples:

> - Encourage & support OCaml courses for students
> - Promote the language in the industrial world

-------------------------

benjamin-thomas | 2022-12-19 21:22:11 UTC | #80

[quote="jonludlam, post:76, topic:10958"]
Yes! I fully agree that testable example stuff is essential. I made a PR to add mld support to mdx to do exactly this a while back, but I‚Äôm afraid I got a bit distracted from it and didn‚Äôt get around to making the required changes:
[/quote]

Looking promising :)

Do you think this could work with `.ml` files too?

-------------------------

geoffder | 2022-12-19 21:40:03 UTC | #81

You might find this [discussion](https://discuss.ocaml.org/t/documenting-library-usage-examples-with-odoc/10101) about documented examples interesting. As mentioned in the thread, there is a long open PR for doing the kind of thing that `mdx` offers in `.mli`s with `odoc`, but the hacked together solution I describe in the there works pretty well for my purposes in the meantime. Since the way I'm doing it goes the reverse direction (from `.ml` to markup) all of the usual tooling you have available works as is.

-------------------------

jhw | 2022-12-19 23:52:36 UTC | #82

[quote="jhw, post:16, topic:10958"]
...[one thing] I feel makes life difficult for OCaml users, the available unit test frameworks. The best one is probably Alcotest, but it‚Äôs not great, and I haven‚Äôt adopted it myself yet.
[/quote]

**Update!**: I broke down and started a new project to split the foundations of [Orsetto](https://opam.ocaml.org/packages/orsetto/) from its data interchange languages, i.e. CBOR and JSON. For this effort, I'm rewriting everything from the cold blocks using **OCaml 5**, **Dune** and **Alcotest**. My opinion of the latter two is better informed now, if not improved all that much.

**Dune** is still a beast, and I do not love it, but at least it seems capable of replacing **OMake** as my build tool, and I'll trade its annoying opinions about how to structure a package in exchange for a decent library of plugins and tooling support. (I think wanting to use coverage and profiling tools without needing to hack with my bare hands on a bunch of squirrelly **OMake** library code to get there, that's what finally pushed me to capitulate.

**Alcotest** is nice. About the best that I expect can be done given the limitations of the OCaml programming language. I do not miss **OUnit** not even a little bit, and I _am_ grateful that **Dune** made it so easy for me to adopt it. I hope my experience with `instrumentation` will be similarly easy. Maybe I'll even adopt **ocamlformat** at some point just so I can trade my 80-column margins for 132-column ones.

Look at me, living in the 21st century now.

When I last looked at **MDX**, it did not strike me as the sort of tool you use to achieve fullly covered and profiled testing. It's for making sure the example code in your comments and ancillary documentation is correct, right? Short shameful confession time: not having a decent system for automatically checking the correctness of my example code has been the principal reason I've been hesitant to write any example code in my documents.

-------------------------

rgrinberg | 2022-12-20 00:48:29 UTC | #83

@mro Good point. People might remember that several years ago we had a large spurt of growth due to Reason. Eventually, we realized it wasn't sustainable because the ecosystem wasn't mature enough to welcome all the newcomers. Growth is good, but we shouldn't bite more than we can chew.

@talex5 why do you prefer mdx over ppx_expect? I'd rather write my tests in OCaml than markdown given all the problems you just mentioned. I see mdx more of a literate documentation tool.

-------------------------

yawaramin | 2022-12-20 02:08:52 UTC | #84

Comparing to Reason feels a little apples to oranges. Reason explicitly tried to create its own community. It didn't try to grow the OCaml community. There was a small influx of people who discovered OCaml as a result but I think it's fair to say that they have mostly been trying to contribute to and grow the OCaml community.

-------------------------

alan | 2022-12-20 05:44:18 UTC | #85

I remember when BuckleScript/Reason got popular. That was around the time I started getting into OCaml (HN has a highly voted submission about BuckleScript from 2016, which is earlier than I remember and before I started writing OCaml, if I recall correctly.) I was not a NodeJS person and my motivation for learning OCaml was to get experience with typed functional programming, not integrate with NodeJS.

At one point, I was trying to choose between BuckleScript and js_of_ocaml; the former seemed classier (Backed by Bloomberg! Readable JS!) but seemed tailored more to the NodeJS ecosystem than the existing OCaml one. I ultimately chose js_of_ocaml, which seemed to be preferred by the established OCaml ecosystem.

I remember disliking the Reason syntax. One aspect that I really disagreed to was the function application syntax, which uses a comma-separated list of arguments despite the fact that functions were still curried. If I could put into words why I found this ugly, I'd say it's because the concrete syntax and abstract syntax aren't isomorphic (is this right?). For example, `f x y` can map to either `f(x, y)` or `f(x)(y)`.

The BuckleScript versus Reason distinction was confusing branding and the splinter into ReScriot was even more confusing. If I understand this correctly: BuckleScript was a compiler from OCaml to JS and Reason is an alternate syntax for OCaml that can map to OCaml source code. However, BuckleScript became ReScript, which has a new syntax which is incompatible with OCaml's?

I feel that the BuckleScript/ReScript project largely kept to the NodeJS crowd and stayed independent of the OCaml ecosystem around what is published on OPAM. I'm worried if the BuckleScript branding confused people who could have gotten into OCaml, but I don't think it did damage: At worst it was neutral, attracting people who mainly used NodeJS and were interested in NodeJS interoperability, then forked OCaml, taking the new NodeJS people with it.

-------------------------

bluddy | 2022-12-20 08:01:00 UTC | #86

[quote="rgrinberg, post:83, topic:10958"]
People might remember that several years ago we had a large spurt of growth due to Reason. Eventually, we realized it wasn‚Äôt sustainable because the ecosystem wasn‚Äôt mature enough to welcome all the newcomers. Growth is good, but we shouldn‚Äôt bite more than we can chew.
[/quote]

I think this is the wrong analysis of what happened. Reason was killed (effectively) by its key component (Bucklescript) deciding to go their own way. While Reason was growing, we kept getting an  influx of people into OCaml which was and is a huge benefit, and had it kept going, we would have seen this benefit continue. Bigger IS better in communities, with very few exceptions. More people means more contributors, more blog posts, more innovation, more competition, more applications using the language -- all good things.

-------------------------

bluddy | 2022-12-20 08:05:34 UTC | #87

There's really no such thing as 'sustenance' in languages. The reason is that the language space is massively competitive. If we cannot give people reasons to use OCaml, they will switch to other, more competitive languages. The reason the OCaml community is small is to a very large degree because we're lagging behind other communities in key features (debugging, ecosystem, language features etc). This is a chicken and egg problem, because had we been bigger, we could have provided these features more easily, which would bring have brought in more people, etc.

-------------------------

mro | 2022-12-20 08:31:29 UTC | #88

[quote="bluddy, post:87, topic:10958"]
‚Äòsustenance‚Äô in languages
[/quote]

I was talking about the community, not the language. Growth isn't a value per se. But this would become OT.

Initially the thread was about onboarding. Which is necessary but not sufficient. In the end it's about what priorities a community has and naturally different communities may have different ones. Maybe there is a place for those disgusted by ever breaking things. I for one value reliable results and accept initial friction.

However, what helped me navigate the confusion was

* recipes  and reports what worked (the IMO not bad docs, real-word ocaml, Cornell course, blog articles, ideally found in this forum),
* early and expressive compiler messages (hm..),
* a friendly, responsive and competent crowd like the one here,
* a bit of stubbornness,
* the confidence the grass isn't greener elsewhere.

And the end result has some properties, I don't want to go without.

-------------------------

bluddy | 2022-12-20 08:54:11 UTC | #89

Indeed the balance is to grow while maintaining the things that keep the language unique and useful. I think OCaml has long known how to do the latter. The former requires listening to users and best practices and adapting.

At the end of the day, OCaml isn't offering any particularly unique feature. What it offers is a 'sweet spot' - a particular mix of features that balance purity with practicality. In order to maintain this notion of a sweet spot, advances need to be made constantly to compete with other languages with bigger communities. Growth of the community is generally a sign of success - it means we've provided that sweet spot to more and more people, so that they find value in the language.

-------------------------

jhw | 2022-12-20 10:10:31 UTC | #90

[quote="Jon_Harrop, post:28, topic:10958"]
I‚Äôm curious about the opposite language design. What if a language had ints, floats, chars, tuples, strings, arrays, sets and maps with polymorphic equality, comparison, hashing, pretty printing and serialization built-in?
[/quote]

Sounds like [Raku](https://raku.org) to me... which is a fine language and more people should know about it.

-------------------------

talex5 | 2022-12-20 11:09:22 UTC | #91

> @talex5 why do you prefer mdx over ppx_expect?

I used ppx_expect in OCluster, and that worked too. Some advantages of MDX:

1. Projects always need examples, so you always need a dependency on MDX. Since it works for tests too, it's good to avoid the extra dependency on ppx_expect.

2. As I recall, ppx_expect wants tests to be mingled with the source code. This requires the source to be pre-processed to get rid of the tests during a regular build, so you end up making ppx_expect a dependency for everyone, not just developers wanting to run tests. Or, you do what OCluster does, and make a fake extra library with nothing but tests. But that causes trouble too (e.g. https://github.com/ocurrent/ocluster/pull/139).

3. Having the tests inside the library encourages writing tests that depend on internal APIs, which I usually prefer to avoid. With MDX, I can often just add a `val dump : t Fmt.t` and use that, which is also useful for users of the library trying to debug things.

4. MDX syntax is a bit nicer IMO.

If you're running something within Lwt or Eio, ppx_expect does let you put the output exactly where it's expected though, whereas with MDX you put it after the main-loop finishes. That could probably be fixed in MDX with a concurrency-aware version.

The lack of merlin, etc isn't a big problem for me because test cases tend to be short, and for larger cases you can get MDX to import code from a separate .ml file.

-------------------------

matty | 2022-12-20 16:17:01 UTC | #92

I just tried to get up and running with OCaml last night. For me, the difficulty was the tooling and the documentation around the tooling. 

**General Language documentation**
1. I could find virtually no information on how OCaml works with its REPL in a development workflow, beyond that "there is a REPL but we don't use that one, we use this other one". Trying to figure out where on the spectrum between a python REPL or a common lisp fully integrated development experience was actually was a challenge - and I still don't know the answer. How are OCaml developers working with the REPL? Am I writing my programs from "within" my program like I would if I were writing Common Lisp or Clojure? This sort of thing is hard to find any information about. 

**With OPAM:** 
1. The notion of a "switch" was an odd one. Having a global "switch" is very strange to me. Managing these is very obtuse. You need to reinstall all your development tools for a different switch version. I am used to a more project-local lock in of library versions, and a more global installation of development tooling (things like the language server protocol, utop, etc). For example, npm in the javascript universe allows you to install things globally, but also only project-locally. The tool knows which one to use based on what directory you're in. That's much easier and I think more sense making. Reinstalling all the dev tools if you jump switches seems kind of silly. I am sure that there are good technical reasons for this, but it is weird coming from the outside. 
2. Having to explicitly run `opam init` seems not entirely necessary. However that leads to my next weird thing: 
3. Having to run `eval $(opam env --shell=fish)` or whatever your shell is in order to get everything in your active "switch" available on your path. Someone else somewhere in this thread rather proudly pointed out that `opam init` will modify your shell profile for you! I manage these things in version control why would I ever want some random thing changing them? That would be ridiculous. Now, this environment set up being per-user and per-shell is fine, I am used to that with node and `nvm`. However, this requirement to eval the result of some magic spell is very easy to miss, and I only realized it when the OCaml adjacent emacs modes were unable to stand up. 

My "solution" to the above was to just install `direnv` and set up an `.envrc` file in my project's top level to run the right eval command. Emacs has a `direnv` package that just makes this work. I did have to burn a not insignificant amount of time figuring this out, but it works and I don't have to pollute my shell configuration with random stuff that IMO doesn't really belong there. 

**With the editor integrations (emacs specifically)**
0. I am aware that opam has something called "user setup". Again, my emacs config is something I have under source control - why would I ever want something modifying it directly without knowing what it was going to do? That is just a total non-starter. I set it up myself. Also I don't believe the user setup lets you use the OCaml LSP implementation for emacs but instead forces you into using something called "merlin". OCaml is the _only_ language ecosystem I know of that does something like this "user setup". I was not inclined to go that route because it was unfamiliar to me and because I don't want anything touching my configurations but me. Speaking of "merlin" though:
1. The differentiation between merlin and the language server protocol implementation is very confusing. The one depends heavily on the other apparently and the difference between them isn't really spelled out anywhere. Which one should I be using? Who knows, good luck. 
2. If you were like me and chose the language server protocol implementation, then you need to be aware that the LSP is only able to work if you run a build so it can I guess find build artifacts which are required for most of the OCaml LSP features. After initializing a dune project, I need to repeatedly run `dune build` whenever I do anything apparently. Even when creating a blank file. As far as I can tell this requirement for the OCaml LSP is documented absolutely nowhere. 

Actually [the only place I found reference to it was the documentation for the OCaml Platform for VSCODE](https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform), under the `Setting up the extension for your project` section. Like, come on guys - for real?? [I did find an issue in the LSP repo outlining some documentation improvements specifically in this area](https://github.com/ocaml/ocaml-lsp/issues/900) so I am glad that is at least being tracked by them. I appreciate that good documentation is very difficult to write. This was very confusing, as no other LSP I've worked with thus far needed me to run some process in my terminal. Maybe the other LSPs I work with are running something in the background. I write some clojure and I use their language server protocol implementation and no such thing is  explicitly required as a user step for enabling any LSP features such as "go to definition" etc. 

I feel that the LSP should be smart enough to realize that there is a `dune-project` file in the top level of the project and just do the right thing for me, or I should be able to communicate with Dune from within emacs in a much smoother way. 

3. Dune. Dune uses S-expressions. That's fine. I come from lisp so that is not very bothersome .It is unfortunate that there are two very different sets of syntax to now worry about, but I think that is mostly manageable. It was bothersome to figure out what packages I needed in order to work with dune files. From what I recall, I found virtually no reference of the `dune` package or its setup on the Dune build tool's site or its documentation. It would be good to provide these things. Apparently there is ANOTHER package for _formatting_ the dune files too but I haven't even gotten to that yet. Perhaps also suggesting that users install and configure other things like paredit to make working with s-expressions a bit easier would be a good addition to those docs as well.

Getting from zero to the point where I could write my first function definition, and send it to the REPL was an absolute labyrinth. It was more than a little frustrating having to comb through issue trackers in various repositories, googling, taking to IRC (by the way for anyone wondering IRC is still full of rude people who will go out of their way to make you feel stupid for not knowing how the LSP works),  looking for solutions to problems that should not be problems. 

At this stage in my computer career, I precious limited free time. OCaml has a lot to offer but the developer experience and tool UX is not great. It is a very confusing landscape that took me a long time to navigate over a couple days. I appreciate your patience reading this word-dump. I hope it was not taken in offense, but rather a still-fresh accounting of difficulties. Thanks.

-------------------------

mimoo | 2022-12-20 16:24:57 UTC | #93

BTW some more discussion on reddit: https://www.reddit.com/r/ocaml/comments/zqfoq5/what_are_the_biggest_reasons_newcomers_give_up_on/

-------------------------

rgrinberg | 2022-12-20 17:03:52 UTC | #94

@jhw there's probably no need to remind you, but dune doesn't force you to delete your existing build system. It should be easy enough to maintain dune files on the side for some tooling/profiling needs you have and build the rest with omake. Could you describe some of these opinions of dune that annoyed you? I'm curious about what can be improved.

@bluddy no, size isn't everything. Unless you think "any publicity is good publicity" and scores of jaded people with negative first impressions of the language is a good thing. The simple fact is that OCaml as a language isn't (yet) as accessible as other languages as Python. Pretending like it is and putting potential users through pain is going to back fire on us in the long run. We should set the expectation clearly that getting up and running requires getting your hands dirty even if that isn't going to turn away some users at first.

@talex5 #2 is an issue that is worked around by putting your ppx_expect tests in separate libraries. That doesn't let you test internal api's, but mdx has the same problem. I suppose another advantage of mdx is that isn't tied to ppxlib. FWIW, it shouldn't be too hard to add editor support to mdx files. Would be an interesting first project for lsp/merlin if anyone is interested.

-------------------------

rgrinberg | 2022-12-20 18:58:12 UTC | #95

Thanks for all the feedback, some of it is useful and I appreciate you writing it.

[quote="matty, post:92, topic:10958"]
by the way for anyone wondering IRC is still full of rude people who will go out of their way to make you feel stupid for not knowing how the LSP works
[/quote]

Really? I always found the opposite to be the case. Given your post, I have a very good idea that the interaction with "rude people" was in fact with me. I don't think I was rude at all, but I'll share the entire exchange with everyone else, so that they can see for themselves if IRC is as bad as you're saying.

```text
[19:11:39] mister_m I started a dune "lib" project, and I have emacs telling me "no config found for file" and suggests running dune build. What does this mean?
[19:12:05] rgrinberg means that you need to run $ dune build in your project
[19:12:09] mister_m why
[19:13:02] mister_m Immediately when I create a new .ml file I see this error through the lsp and flymake
[19:13:59] rgrinberg ocamllsp can only provide you with editor functionality if it knows where the build artifacts are
[19:15:54] mister_m so dune build needs to be run whenever I make a new file in a project??
[19:16:02] rgrinberg yes
[19:16:41] mister_m that's ridiculous
[19:16:52] mister_m but thank you for explaining why I am seeing that
[19:17:16] rgrinberg you're welcome
```

-------------------------

bnguyenvanyen | 2022-12-20 21:12:50 UTC | #96

Hi,
Thank you for all the feedback !
One point which could help with this :
> or I should be able to communicate with Dune from within emacs in a much smoother way.

You can use the watch mode `dune build -w` and you won't have to rerun `dune build` manually (or `dune build -w @check` if you need it to be more snappy and it's just for the editor).

-------------------------

timmy_jose | 2022-12-21 03:57:55 UTC | #97

[quote="jbeckford, post:13, topic:10958"]
In contrast to all the above environmental problems, the OCaml language itself has been relatively easy to understand (so far!). I think that is because we can write substantial programs in OCaml without having to know much advanced OCaml (honestly, how often do we need first-class modules and GADTs?). That is in contrast to other languages like Rust where advanced understanding is needed for even trivial programs.
[/quote]

As a Rust expert and an OCaml newbie, I absolutely agree with this sentiment. The rest of the points you made are also very compelling, and even as an experienced developer, I've faced/am facing almost all of those issues as well. It's just that my experience with a variety of language ecosystems makes it easier to handle, but I can imagine what a nighrmare (off-putting to boot) it must be for absolute beginners.

-------------------------

timmy_jose | 2022-12-21 04:04:12 UTC | #98

That's called obsolescence, not thriving and sustenance.

-------------------------

timmy_jose | 2022-12-21 04:15:46 UTC | #99

This would also help with the proper lack of Windows support. More users -> more Windows users -> more people to help across all platforms -> more users for OCaml. A veritable positive feedback loop.

(Forgive the cross-reply - the forum doesn't allow more than 3 responses in the same thread for new users, apparently)

@rgrinberg 

In general, my own experience on the IRC channel on Libera has been one of two:

  1. No responses whatsover, or
  2. Useless responses.

to the point that I've given up. The Discord channel (unofficial?) has been far more helpful and responsive.

Then again, I'm a beginner in OCaml. Maybe it's more useful for veterans.

-------------------------

jhw | 2022-12-21 04:37:12 UTC | #100

[quote="timmy_jose, post:98, topic:10958, full:true"]
That‚Äôs called obsolescence, not thriving and sustenance.
[/quote]

I dunno comrade, when a programming language community has been around as long as this one, failing to die outright from old age is thriving. This one is old enough that thinking about posterity is probably more important to us than climbing the ladder.

-------------------------

